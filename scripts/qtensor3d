#!/usr/bin/env python

import getopt
import os
import sys
from q3d.loaddump import load_json
import q3d.uflcache as uflcache
from firedrake import COMM_WORLD as comm
from q3d.firedrakeplus import ManuQ
from q3d.firedrakeplus import set_eqn_globals, solve_PDE, compute_energy, errorL2, errorH1, choose_mesh
import q3d.printoff as pr

def print0(*args,**kwargs):
    if comm.rank == 0:
        print(*args,**kwargs)

def usage():
    usage_str = """usage:
    qtensor3d [-o] [--no-gd] [--dt={0}step-size{1}] [--num-steps={0}num-steps{1}]
              [--save-every={0}save-every{1}] {0}save-directory{1}

Opens save at {0}save-directory{1} and solves.
              
options:
    -o                          overwrite mode
    --no-gd                     turns off gradient descent and directly solves
    --dt={0}step-size{1}              specify the step size of gradient descent
    --num-steps={0}num-steps{1}       specify the number of time steps
    --save-every={0}save-every{1}     specify the number of steps before saving state""".format('\033[4m','\033[0m')
    print0(usage_str)

def answers_yes_to(input_message):
    while True:
        answer = input(input_message) if comm.rank == 0 else None
        answer = comm.bcast(answer,root=0)
        if answer in ('y','Y'):
            return True
        if answer in ('n','N'):
            return False

def check_if_valid_save(path):
    if not os.path.exists(path):
        print0(f'no save at path "{path}"')
        sys.exit()
    for filename in ('constants.yml','settings.yml','userexpr.yml'):
        if not os.path.exists(f'{path}/{filename}'):
            print0(f'missing file: "{filename}"')
            sys.exit()

def check_if_checkpoint_exists(path):
        if not os.path.exists(f'{path}/chk/checkpoint.h5') and (not os.path.exists(f'{path}/chk/q_soln.h5') or not os.path.exists(f'{path}/chk/q_prev.h5')):
            print0("cannot resume since no checkpoint found. Try overwriting instead.")
            sys.exit()

def run(path, *, mode='r', supersessions={}):
    # these three modules must be imported in order and before other modules, or else they won't work properly
    import q3d.config as config
    config.initialize(f'{path}/settings.yml',f'{path}/constants.yml',supersessions)
    from q3d.config import settings
    from time import sleep

    import q3d.saves as saves
    saves.initialize(mode,path)

    # import other modules
    import q3d.printoff as pr
    from q3d.misc import Timer, get_range, check

    # print info
    pr.constants_info()
    pr.settings_info()

    # perform a check that will ensure the elastic constants are physical
    check.elastic_constants()

    sleep(1)
    pr.stext(f'PRELIMINARY COMPUTATIONS:',color='uline')

    # perform sympyplus preliminary computations
    timer = Timer()
    timer.start()

    import q3d.compute as compute
    comp = compute.compute()

    timer.stop()

    # rebuild UFL cache if in overwrite mode
    if mode == 'o':
        pr.text("Rebuilding UFL cache...",end=' ')
        uflcache.build_uflcache(path)
        pr.text("build successful.")

    # if, however, the UFL cache is missing, rebuild it regardless of the mode
    try:
        uflcache_dict = load_json(f'{path}/uflcache.json')
    except FileNotFoundError:
        pr.text("UFL cache not found. Rebuilding...",end=' ')
        uflcache.build_uflcache(path)
        pr.text("build successful.")
        uflcache_dict = load_json(f'{path}/uflcache.json')

    pr.stext(f'Finished preliminary computations in {timer.str_time}.')
    sleep(1)
    pr.stext(f'PDE SOLVE:',color='uline')

    # allow for multiple refinement levels for an in-depth comparison
    for refinement_level in get_range(settings.mesh.refs):
        # choose mesh, depending on the mesh source and mesh name, as well as the refinement level
        mesh = choose_mesh(settings.mesh.source, settings.mesh.name, refinement_level=refinement_level)

        # set equation globals to initialize
        set_eqn_globals(comp,uflcache_dict)

        # solve PDE and get info about it
        q_soln, time_elapsed, times, energies, completed = solve_PDE(mesh,ref_lvl=refinement_level)

        # in case q_soln was loaded with a mesh from checkpoint, use this mesh instead of the other one
        mesh = q_soln.function_space().mesh()

        # if a manufactured solution was specified in userexpr.yml,
        # go ahead and compute its energy, and compare it to the
        # solution we got from solve_PDE()
        if 'manu_q' in uflcache.load_userexpr_yml(path).keys():
            q_manu = ManuQ(mesh)
            manu_energy = compute_energy(q_manu)
            h1_error = errorH1(q_soln,q_manu,mesh)
            l2_error = errorL2(q_soln,q_manu,mesh)

            # print a verbose summary of the PDE solve info
            try:
                pr.pde_solve_info(refinement_level=refinement_level,
                    h1_error=h1_error,
                    l2_error=l2_error,
                    energy=energies[-1],
                    custom={'title':'Manu. Sol. Energy','text':manu_energy},
                    time_elapsed=time_elapsed)
            except IndexError:
                pass
            
            # returns True if solve completes, False if convergence error occurs
            return completed
        
        # if a manufactured solution was not specified, then print
        # an abbreviated summary of the PDE solve info
        try:
            pr.pde_solve_info(refinement_level=refinement_level,energy=energies[-1],time_elapsed=time_elapsed)
        except IndexError:
            pass
        
        # returns True if solve completes, False if convergence error occurs
        return completed

def resume_save(path, *, supersessions):
    check_if_valid_save(path)
    check_if_checkpoint_exists(path)

    pr.text(f"resuming save at '{path}'")
    return run(path, mode='r', supersessions=supersessions)

def overwrite_save(path, *, supersessions):
    check_if_valid_save(path)

    if answers_yes_to(f"will overwrite save at '{path}'. Are you sure you want to continue? (y/n) "):
        pr.text(f"overwriting save at '{path}'")
        return run(path, mode='o', supersessions=supersessions)

    print0('exiting')

def auto_run(path, *, overwrite=False, supersessions):
    check_if_valid_save(path)

    # default supersessions given here, may be overriden on command line
    supersessions['dt'] = supersessions.get('dt', 0.001)
    supersessions['num-steps'] = supersessions.get('num-steps', 50)
    supersessions['save-every'] = supersessions.get('save-every', 50)
    if 'no-gd' in supersessions:
        print0("cannot choose --no-gd in auto mode")
        sys.exit()
    
    for i in range(100):
        completed = False
        while not completed:
            if i == 0 and overwrite:
                completed = overwrite_save(path, supersessions=supersessions)
            else:
                completed = resume_save(path, supersessions=supersessions)

            if completed:
                supersessions['dt'] *= 10
                continue

            supersessions['dt'] *= 0.1

def main():
    sys_argv = sys.argv[1:]
    if len(sys_argv) == 0:
        print0('no argument supplied')
        sys.exit()

    try:
        opts, listargs = getopt.getopt(sys.argv[1:],'oa',['no-gd','dt=','num-steps=','save-every=','help'])
    except getopt.GetoptError as err:
        # print help information and exit:
        print0(err)
        print0('use --help for usage')
        sys.exit()

    # resume mode is default
    overwrite = False
    auto = False
    supersessions = {}

    for o, a in opts:
        # change to overwrite mode
        if o in ('-o'):
            overwrite = True
        elif o in ('-a'):
            auto = True
        # allow for supersessions over what was specified in settings/constants files
        elif o in ('--no-gd','--dt','--num-steps','--save-every'):
            supersessions[o[2:]] = a
        # get help
        elif o in ('--help'):
            usage()
            sys.exit()
        else:
            sys.exit()
    
    # overwrite or resume
    if auto:
        auto_run(listargs[-1], overwrite=overwrite, supersessions=supersessions)
        return
    
    if overwrite:
        overwrite_save(listargs[-1], supersessions=supersessions)
        return
    
    resume_save(listargs[-1], supersessions=supersessions)

if __name__ == '__main__':
	main()

# END OF CODE
